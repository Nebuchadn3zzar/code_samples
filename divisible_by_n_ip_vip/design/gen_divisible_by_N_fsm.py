#!/usr/bin/env python3

################################################################################
# Description:
#    * Generates a Verilog module that takes a bitstream as input, and outputs
#      whether the bitstream thus far is divisible by a fixed integer divisor N
#
# Output:
#    * A file, named according to the 'out_file_name' positional argument, that
#      contains a 'divisible by N' Verilog module
#    * Prints to standard output whether the script succeeded
#
# Examples:
#    * gen_divisible_by_N_fsm.py 3 divisible_by_3.v
#      Generates an FSM in a file named "divisible_by_3.v" that outputs '1'
#      whenever its input bitstream thus far is divisible by 3, and '0'
#      otherwise
#    * gen_divisible_by_N_fsm.py 5 divisible_by_5.v
#      Generates an FSM in a file named "divisible_by_5.v" that outputs '1'
#      whenever its input bitstream thus far is divisible by 5, and '0'
#      otherwise
#    * gen_divisible_by_N_fsm.py --help
#      Prints description of this script and its arguments, then exits
#
# Limitations:
#    * Imposes no upper bound on N, allowing user to go wild
################################################################################


# Modules
import argparse
import logging as log
import math
import os
import sys
import time

# Constants
LOGGER_FMT = "%(levelname)s: %(message)s"

class DivCheckerGenLib:
    """
    Streaming divisibility checker RTL generator library.
    """

    def __init__(self, logger, divisor, orig_cmd_str):
        self.log = logger
        self.divisor = divisor
        self.orig_cmd_str = orig_cmd_str

    def validate_cfg(self):
        """
        Perform some sanity checks and input sanitation.
        """

        self.log.info("Performing sanity checks and input sanitation...")

        # Check that divisor is non-negative and non-zero
        if self.divisor <= 0:
            msg = f"Given divisor {self.divisor}, but divisor must be a " \
                  f"non-negative and non-zero number"
            raise Exception(msg)

        # Check that divisor is not 1
        if self.divisor == 1:
            msg = f"Given divisor {self.divisor}, but all numbers are " \
                  f"divisible by 1; a 'divisible by 1' FSM would be pointless"
            raise Exception(msg)

    def gen_verilog_src(self, out_file_name):
        """
        Open output file handle and generate and write Verilog source code to
        output file.
        """

        # Open file handle
        self.log.info(f"Opening output file handle '{out_file_name}'...")
        if os.path.exists(out_file_name):  # Output file already exists
            self.log.warning(f"Overwriting existing file '{out_file_name}'")
        out_fh = open(out_file_name, "w")

        self.log.info("Generating and writing Verilog source code to output " \
                      "file...")

        # File header
        timestamp = time.strftime("%a %Y-%m-%d %I:%M:%S %p")
        out_fh.write("/" * 79 + "\n")
        out_fh.write(f"// Generated by the following command on {timestamp}:\n")
        out_fh.write(f"// {self.orig_cmd_str}\n")
        out_fh.write(f"//\n")
        out_fh.write(f"// Description:\n")
        out_fh.write(f"//    * Takes a bitstream as input\n")
        out_fh.write(f"//    * Outputs whether the bitstream thus far is divisible by {self.divisor}\n")
        out_fh.write(f"//    * Both input and output are qualified by 'valid' signals\n")
        out_fh.write("/" * 79 + "\n")
        out_fh.write("\n")
        out_fh.write("\n")

        # Module declaration
        out_fh.write(f"// \"Divisible by {self.divisor}\" finite state machine\n")
        out_fh.write(f"module divisible_by_N(clk, rst_n, in, in_vld, out, out_vld);\n")

        # State enumerations
        out_fh.write(f"    // State enumerations\n")
        num_state_bits = math.ceil(math.log2(self.divisor))  # Bits required to encode N states
        for i in range(self.divisor):
            i_bin_padded = "{:b}".format(i).zfill(num_state_bits)
            out_fh.write(f"    localparam s_mod{i} = {num_state_bits}'b{i_bin_padded};\n")
        out_fh.write(f"\n")

        # Input, output, wire, reg declarations
        out_fh.write(f"    // Input, output, wire, reg declarations\n")
        out_fh.write(f"    input wire clk, rst_n, in, in_vld;\n")
        out_fh.write(f"    output wire out, out_vld;\n")
        out_fh.write(f"\n")
        out_fh.write(f"    reg [{num_state_bits - 1}:0] cs, ns;\n")
        out_fh.write(f"    reg vld_d1;  // Input valid signal, but delayed by 1 clock\n")
        out_fh.write(f"\n")

        # Sequential logic
        out_fh.write(f"    // Sequential logic\n")
        out_fh.write(f"    always @(posedge clk) begin\n")
        out_fh.write(f"        if (~rst_n) begin\n")
        out_fh.write(f"            cs     <= 'd0;\n")
        out_fh.write(f"            vld_d1 <= 'd0;\n")
        out_fh.write(f"        end\n")
        out_fh.write(f"        else begin\n")
        out_fh.write(f"            if (in_vld) cs <= ns;  " \
                     f"// Advance state only when input is valid\n")
        out_fh.write(f"            vld_d1 <= in_vld;      " \
                     f"// Indicates that output result is valid\n")
        out_fh.write(f"        end\n")
        out_fh.write(f"    end\n")
        out_fh.write(f"\n")

        # State transition combinational logic
        out_fh.write(f"    // State transition combinational logic\n")
        out_fh.write(f"    always @(*) begin\n")
        out_fh.write(f"        case (cs)\n")
        for i in range(self.divisor):
            one_trans  = ((i * 2) + 1) % self.divisor  # Transition to take if next bit is '1'
            zero_trans = ((i * 2)    ) % self.divisor  # Transition to take if next bit is '0'
            out_fh.write(f"            s_mod{i}:  ns = (in) ? s_mod{one_trans} : s_mod{zero_trans};\n")
            self.log.debug(f"s_mod{i} state transitions: " \
                           f"1 -> s_mod{one_trans}, " \
                           f"0 -> s_mod{zero_trans}")
        out_fh.write(f"            default: ns = cs;\n")
        out_fh.write(f"        endcase\n")
        out_fh.write(f"    end\n")
        out_fh.write(f"\n")

        # Output wire assignments
        out_fh.write(f"    // Output wire assignments\n")
        out_fh.write(f"    assign out     = (cs == s_mod0);  " \
                     f"// If in state 's_mod0', divisible by {self.divisor}\n")
        out_fh.write(f"    assign out_vld = vld_d1;          " \
                     f"// Output delay is always exactly 1 clock\n")

        # End module declaration
        out_fh.write(f"endmodule : divisible_by_N\n")
        out_fh.write(f"\n")

        # Close file handle
        out_fh.close()

def main(argv):
    # Configure argument parser
    desc_str = "Generates a Verilog module that takes a bitstream as input, " \
               "and outputs whether the bitstream thus far is divisible by " \
               "a fixed integer divisor N"
    parser = argparse.ArgumentParser(description=desc_str)
    parser.add_argument(
        "divisor",  # Positional argument
        type=int,
        action="store",
        help="Fixed integer divisor N of generated 'divisible by N' Verilog " \
             "module",
    )
    parser.add_argument(
        "out_file_name",  # Positional argument
        type=str,
        action="store",
        help="Desired name of generated Verilog source file",
    )
    parser.add_argument(
        "-v", "--verbose",  # Optional argument
        action="store_true",
        help="Enables verbose logging to facilitate debugging",
    )

    # Parse arguments and configure logger
    args = parser.parse_args()
    log.basicConfig(
        format=LOGGER_FMT,
        level=(log.DEBUG if args.verbose else log.INFO),
    )
    log.info("Parsing arguments...")
    for (arg, val) in sorted(vars(args).items()):
        log.info("   * {}: {}".format(arg, val))

    # Print current time
    log.info(time.strftime("%a %Y-%m-%d %I:%M:%S %p"))

    # Store complete command line string for inclusion in header of generated
    # Verilog source file
    orig_cmd_str = sys.argv[0] + " " + " ".join(sys.argv[1:])

    # Instantiate streaming divisibility checker RTL generator library class
    rtl_gen_lib = DivCheckerGenLib(log.getLogger(), args.divisor, orig_cmd_str)

    # Perform some sanity checks and input sanitation
    rtl_gen_lib.validate_cfg()

    # Generate and write Verilog source code to output file
    rtl_gen_lib.gen_verilog_src(args.out_file_name)

    # Exit
    log.info("Done.")
    sys.exit(0)  # Success

# Execute 'main()' function
if (__name__ == "__main__"):
    main(sys.argv)

