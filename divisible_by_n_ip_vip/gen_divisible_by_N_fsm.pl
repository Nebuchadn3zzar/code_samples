#!/usr/bin/env perl

################################################################################
# Description:
#    * Generates a 'divisible by N' finite state machine in Verilog
#
# Arguments:
#    * -n N
#    * -o output_file_name.v
#
# Output:
#    * A file, named according to the '-o' option, that contains a 'divisible by N' FSM in Verilog
#    * Prints to standard output whether the script succeeded
#
# Examples:
#    * gen_divisible_by_N_fsm.pl -n 3 -o divisible_by_3.v
#      Generates an FSM in a file named "divisible_by_3.v" that outputs '1' whenever its input bitstream thus far is
#      divisible by 3, and '0' otherwise
#    * gen_divisible_by_N_fsm.pl -n 5 -o divisible_by_5.v
#      Generates an FSM in a file named "divisible_by_5.v" that outputs '1' whenever its input bitstream thus far is
#      divisible by 5, and '0' otherwise
#
# Limitations:
#    * Imposes no upper bound on N, allowing user to go wild
#    * Uses more states than necessary for even values of N; could use some optimisation
#    * I'm not an RTL designer, so the generated Verilog is by no means bulletproof, and is not likely to be following
#      best practices
################################################################################


# Pragmas and modules
use strict;
use warnings;
use File::Basename;
use Getopt::Std;
use Scalar::Util;
use POSIX;


# Store complete command line string for inclusion in header of generated file
my $script_name = basename($0);
my $command_str = $script_name;
foreach my $arg (@ARGV) {
   $command_str = $command_str . " $arg";
}

# Parse options
our ($opt_n, $opt_o);
getopts('n:o:');
if (!defined($opt_n) or !defined($opt_o)) {
   die("Usage: $script_name -n N -o output_file_name.v\n");
}
my $div_by        = $opt_n;
my $out_file_name = $opt_o;

# Perform some sanity checks and input sanitation
if (!Scalar::Util::looks_like_number($div_by) or ($div_by <= 0)) {
   die("Error: N must be a non-negative and non-zero number!\n");
}
elsif ($div_by == 1) {
   die("Error: All numbers are divisible by 1; a 'divisible by 1' FSM would be pointless!\n");
}
$div_by =~ s/^0+//;  # Remove any leading zeroes
printf("Generating a 'divisible by $div_by' finite state machine and writing it to file \"$out_file_name\"...\n");

# Check whether output file already exists, and then open file handle for writing
if (-f "$out_file_name") {
   printf("Warning: Overwriting existing file \"$out_file_name\"!\n");
}
open(OUT_FILE, "> $out_file_name");

# Write file header
my $date = `date`; chomp($date);
printf(OUT_FILE "////////////////////////////////////////////////////////////////////////////////\n");
printf(OUT_FILE "// This file was generated by \"$script_name\" on $date\n");
printf(OUT_FILE "// Command: $command_str\n");
printf(OUT_FILE "//\n");
printf(OUT_FILE "// Description:\n");
printf(OUT_FILE "//    * Takes a bitstream as input\n");
printf(OUT_FILE "//    * Outputs whether the bitstream thus far is divisible by $div_by\n");
printf(OUT_FILE "//    * Both input and output are qualified by 'valid' signals\n");
printf(OUT_FILE "////////////////////////////////////////////////////////////////////////////////\n");
printf(OUT_FILE "\n");
printf(OUT_FILE "\n");

# Module declaration
printf(OUT_FILE "// \"Divisible by $div_by\" finite state machine\n");
printf(OUT_FILE "module divisible_by_N(clk, rst_n, in, in_val, out, out_val);\n");

# State enumerations
my $num_state_bits = POSIX::ceil(log($div_by) / log(2));  # Number of bits required for N states
my $bin_fmt_str = sprintf("%%0%0db", $num_state_bits);
for (my $i = 0; $i < $div_by; $i++) {
   printf(OUT_FILE "   localparam s_mod$i = $num_state_bits" . "'b" . sprintf($bin_fmt_str, $i) . ";\n");
}
printf(OUT_FILE "\n");

# Input, output, wire, reg declarations
printf(OUT_FILE "   input wire clk, rst_n, in, in_val;\n");
printf(OUT_FILE "   output wire out, out_val;\n");
printf(OUT_FILE "\n");
printf(OUT_FILE "   reg [%0d:0] cs, ns;\n", $num_state_bits - 1);
printf(OUT_FILE "   reg val_d1;\n");
printf(OUT_FILE "\n");

# Sequential logic
printf(OUT_FILE "   always @(posedge clk) begin\n");
printf(OUT_FILE "      if (~rst_n) begin\n");
printf(OUT_FILE "         cs     <= 'd0;\n");
printf(OUT_FILE "         val_d1 <= 'd0;\n");
printf(OUT_FILE "      end\n");
printf(OUT_FILE "      else begin\n");
printf(OUT_FILE "         if (in_val) cs <= ns;  // Advance state machine only when input bitstream is valid\n");
printf(OUT_FILE "         val_d1 <= in_val;      // Indicates that output result is valid\n");
printf(OUT_FILE "      end\n");
printf(OUT_FILE "   end\n");
printf(OUT_FILE "\n");

# State transition combinational logic
printf(OUT_FILE "   always @(*) begin\n");
printf(OUT_FILE "      case (cs)\n");
for (my $i = 0; $i < $div_by; $i++) {
   my $one_transition  = (($i * 2) + 1) % $div_by;  # Transition to take if next bit in bitstream is a '1'
   my $zero_transition = (($i * 2)    ) % $div_by;  # Transition to take if next bit in bitstream is a '0'
   printf(OUT_FILE "         s_mod$i:  ns = (in) ? s_mod$one_transition : s_mod$zero_transition;\n");
}
printf(OUT_FILE "         default: ns = cs;\n");
printf(OUT_FILE "      endcase\n");
printf(OUT_FILE "   end\n");
printf(OUT_FILE "\n");

# Output wire assignments
printf(OUT_FILE "   assign out     = (cs == s_mod0);  // If in state 's_mod0', bitstream so far is divisible by $div_by\n");
printf(OUT_FILE "   assign out_val = val_d1;          // Output delay is always exactly 1 clock\n");

# End module declaration
printf(OUT_FILE "endmodule : divisible_by_N\n");
printf(OUT_FILE "\n");

# Report success and close file handle
printf("Done!\n");
close(OUT_FILE);

